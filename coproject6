opcodes={"add":"00000","sub":"00001","mov1":"00010","mov2":"00011","ld":"00100","st":"00101","mul":"00110","div":"00111","rs":"01000","ls":"01001","xor":"01010","and":"01100","not":"01101","cmp":"01110","jmp":"01111","jlt":"11100","jgt":"11101","je":"11111","je":"11010"}
register={"R0":"000","R1":"001","R2":"010","R3":"011","R4":"100","R5":"101","R6":"110","FLAGS":"111"}
def dectobinary(number):
    a=int(number)
    b=bin(a)
    c=str(b)[2:]
    numberofdig=len(c)
    d=""
    for i in range(0,7-numberofdig):
        d=d+"0"
    d=d+c
    return d
inputfil=open('input.txt','r')
l=inputfil.readlines()
l1=[ele.split(' ') for ele in l]
l2=[]
l3proper=[]
j=0
for i in range(len(l1)):
    if(l1[i]!=['\n']):
        l3proper.append(l1[i])
        l2.append(j)
        j+=1
lbinadrr=[dectobinary(str(ele)) for ele in l2]
#l3proper=[ele for ele in l3proper]
for i in range(len(l3proper)):
    if(l3proper[i][-1][-1]=='\n'):
        temp=l3proper[i][-1][:-1]
        l3proper[i][-1]=temp
print(lbinadrr)
print(l3proper)
def simplearithemetic(l):
    opcode1=opcodes[l[0]]
    d=""
    if l[0] in ["cmp", "not", "div"]:
        reg1=register[l[1]]
        reg2=register[l[2]]
        d=opcode1+"00000"+reg1+reg2
    else:
        reg1=register[l[1]]
        reg2=register[l[2]]
        reg3=register[l[3]]
        d=opcode1+"00"+reg1+reg2+reg3
    return d
def movshift(l):
    d=""
    if(l[0]=="rs" or l[0]=="ls"):
        opcode1=opcodes[l[0]]
        reg1=register[l[1]]
        imme=dectobinary(l[2])
        d=opcode1+"0"+reg1+imme
    else:
        if(l[2].isnumeric()==True):
            opcode1=opcodes["mov1"]
            reg1=register[l[1]]
            imme1=dectobinary(l[2])
            d=opcode1+"0"+reg1+imme1
        else:
            opcode1=opcodes["mov2"]
            reg1=register[l[1]]
            reg2=register[l[2]]
            d=opcode1+"000"+reg1+reg2
    return d
lout=[movshift(ele) for ele in l3proper]
print(lout)
    

